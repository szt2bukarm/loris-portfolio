{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"54c6c1bf-7f26-4d1d-82d4-3a11681b6cec","prop":"phase","transition":{"delay":0,"ease":"easeInOutQuart","duration":5000},"complete":false,"progress":0,"value":0,"endValue":0.83,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uPhase"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"9b8db033-11ac-4036-b369-7b02094239bc","prop":"mix","transition":{"duration":1450,"ease":"easeInOutQuart","delay":0},"complete":false,"progress":0,"value":0,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uMix"}}],"scroll":[],"hover":[],"mousemove":[]},"layerType":"effect","type":"beam","usesPingPong":false,"phase":0.84,"mix":1,"speed":0.1,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;\nuniform float uPhase;\nuniform float uMix;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float TAU = 6.28318530718;vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\nreturn a + b*cos( TAU*(c*t+d) );\n}float drawExpandingRings(vec2 uv, vec2 center, float scale, float angle) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(0.3700, 1. - 0.3700) * 2.;\nuv = uv * rot(0.0000 * TWO_PI) * skew;\ncenter = center * rot(0.0000 * TWO_PI) * skew;\nfloat modulo = fract(uTime * 0.02 + uPhase);\nfloat ringRadius = scale * 0.5 * modulo;\nfloat distFromCenter = length(uv - center);\nfloat ringDist = abs(distFromCenter - ringRadius);\nfloat lineRadius = 1.0000 * modulo;\nfloat brightness = lineRadius / max(0.0001, 1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));brightness = brightness * max(0., 1.-modulo);return brightness * pow(1.-ringDist, 3.);\n}float getBeam(vec2 uv) {\nvec2 pos = vec2(0.5070920574376623, 0.5163664818246181) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawExpandingRings(uv, pos, 1.4000, 0.0000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);float beam = getBeam(uv);\nfloat ssBeam = smoothstep(0.0, 1.0, beam);\nfloat chroma = 0.4;vec3 beamColor = pal(beam,\n(vec3(0.27058823529411763, 0.6039215686274509, 1) + vec3(0.5)) * 0.5,\nvec3(0.5) - vec3(0.27058823529411763, 0.6039215686274509, 1),\nvec3(1.0 - chroma, 1.0, 1. + chroma),\nvec3(chroma, 0., -chroma)\n);beamColor = mix(beamColor, vec3(0.27058823529411763, 0.6039215686274509, 1), mix(1.0, ssBeam, 0.0000)) * beam;\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(4, Tonemap_tanh(beamColor), bg.rgb);\nvec3 result = mix(bg.rgb, blended, uMix);\nresult += dither;vec4 color = vec4(result, max(bg.a, beam));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"beam"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"91e28ad9-7ba4-4ade-82a8-1c51585dc830","prop":"amount","transition":{"delay":3225,"ease":"easeInOutQuart","duration":1000},"complete":false,"progress":0,"value":0,"endValue":0.5,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[],"hover":[],"mousemove":[]},"layerType":"effect","type":"mouseDraw","usesPingPong":true,"amount":1,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uPingPongTexture;uniform float uAmount;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb;\nvec3 mouseTrail = rgb2hsv(mouseRgb);\nfloat angle = mouseTrail.x;\nfloat strength = mouseTrail.z * (uAmount * 5.0);vec2 direction = angleToDir(angle);vec4 bg = texture(uTexture, uv - (direction * 0.1 * strength * 0.0000));\nvec4 color = vec4(0,0,0,1);color.rgb = vec3(strength * mix(mouseRgb, vec3(0, 0.51, 0.97), 1.0000));\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;if(1 > 0) {\nvec3 blendedRgb = blend(1, color.rgb + dither, bg.rgb);\nfragColor = vec4(mix(bg.rgb, blendedRgb, mouseTrail.z), 1.0);\n} else {\nfragColor = mix(bg, color, mouseTrail.z);\n}\n}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}vec2 liquify(vec2 st, vec2 dir) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nst.x *= aspectRatio;\nfloat amplitude = 0.0025;\nfloat freq = 6.;\nfor (float i = 1.0; i <= 5.0; i++) {\nst = st * rot(i / 5.0 * PI * 2.0);\nst += vec2(\namplitude * cos(i * freq * st.y + uTime * 0.02 * dir.x),\namplitude * sin(i * freq * st.x + uTime * 0.02 * dir.y)\n);\n}\nst.x /= aspectRatio;\nreturn st;\n}vec3 calculateTrailContribution(vec2 mousePos, vec2 prevMousePos, vec2 uv, vec2 correctedUv, float aspectRatio, float radius) {\nvec2 dir = (mousePos - prevMousePos) * vec2(aspectRatio, 1.0);\nfloat angle = atan(dir.y, dir.x);\nif (angle < 0.0) angle += TWOPI;\nvec2 mouseVec = mousePos - prevMousePos;\nfloat mouseLen = length(mouseVec);\nvec2 mouseDir = mouseLen > 0.0 ? mouseVec / mouseLen : vec2(0.0);\nvec2 posToUv = (correctedUv - prevMousePos) * vec2(aspectRatio, 1.0);\nfloat projection = clamp(dot(posToUv, mouseDir * vec2(aspectRatio, 1.0)), 0.0, mouseLen * aspectRatio);\nvec2 closestPoint = prevMousePos * vec2(aspectRatio, 1.0) + mouseDir * vec2(aspectRatio, 1.0) * projection;\nfloat distanceToLine = distance(correctedUv, closestPoint);\nfloat s = (1.0 + radius)/(distanceToLine + radius) * radius;\nvec3 color = vec3(angle / TWOPI, 1.0, 1.0);\nvec3 pointColor = hsv2rgb(color);\npointColor = pow(pointColor, vec3(2.2));\nfloat intensity = pow(s, 10.0 * (1. - 0.3500 + 0.1));\nreturn pointColor * intensity;\n}void main() {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 uv = vTextureCoord;\nvec2 correctedUv = (uv) * vec2(aspectRatio, 1.0);vec3 lastFrameColor = texture(uPingPongTexture, uv).rgb;\nvec3 lastFrameColorGamma = pow(lastFrameColor, vec3(2.2));\nvec3 hsv = rgb2hsv(lastFrameColor);\nvec3 hsvGamma = rgb2hsv(lastFrameColorGamma);\nvec2 prevDir = angleToDir(hsv.x);\nfloat prevStrength = hsvGamma.z;\nvec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0);\nfloat dist = length(dir);\nfloat blurAmount = 0.03 * prevStrength;\nuv = uv - prevDir * blurAmount;\nuv = mix(uv, liquify(uv - prevDir * 0.005, prevDir), (1. - prevStrength) * 0.0000);\nlastFrameColor = texture(uPingPongTexture, uv).rgb;\nlastFrameColor = pow(lastFrameColor, vec3(2.2));\nint numPoints = int(max(12.0, dist * 24.0));\nfloat speedFactor = clamp(dist, 0.7, 1.3);\nfloat radius = mix(0.1, 0.7, 0.3900 * speedFactor);\nvec3 trailColor = vec3(0.0);\nint iter = min(numPoints, 24);\nfor (int i = 0; i <= iter; i++) {\nfloat t = float(i) / float(numPoints);\nvec2 interpPos = mix(uPreviousMousePos, uMousePos, t);\nvec2 prevInterpPos = i > 0 ? mix(uPreviousMousePos, uMousePos, float(i-1) / float(numPoints)) : uPreviousMousePos;\ntrailColor += calculateTrailContribution(interpPos, prevInterpPos, uv, correctedUv, aspectRatio, radius);\n}\ntrailColor = trailColor / float(min(numPoints, 50) + 1);\nvec3 blurredLastFrame = vec3(0.0);\nfloat clampedDist = clamp(length(trailColor) * dist, 0.0, 1.0);\nfloat blurRadius = 0.005;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(-blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, blurRadius)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, -blurRadius)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += lastFrameColor * 0.2;\nblurredLastFrame *= pow(0.2200, 0.2);\nvec3 draw = mix(blurredLastFrame, trailColor, clampedDist);\ndraw = pow(draw, vec3(1.0/2.2));\ndraw.r = max(0.0, draw.r - 0.01);\ndraw.g = max(0.0, draw.g - 0.01);\ndraw.b = max(0.0, draw.b - 0.01);\nfragColor = vec4(draw, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"mouse_draw"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"twod_sdf","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/images/TUKXadhSwDabkwZj2ZOWOnPW2md2/eyes_combined_1764522996689.png","sampler":"uCustomTexture"},"speed":0.66,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uCustomTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float median(float r, float g, float b) {\nreturn max(min(r, g), min(max(r, g), b));\n}float screenPxRange(vec2 range) {\nvec2 unitRange = range/vec2(textureSize(uCustomTexture, 0));\nvec2 screenTexSize = vec2(1.0)/fwidth(vTextureCoord);\nreturn max(0.5*dot(unitRange, screenTexSize), 1.0);\n}float sdCustom(vec2 uv) {\nivec2 customTexSize = textureSize(uCustomTexture, 0);\nfloat customTexAspect = float(customTexSize.x) / float(customTexSize.y);if(float(customTexSize.x) == float(uResolution.x) && float(customTexSize.y) == float(uResolution.y)) {\nreturn 1.0;\n}uv.x /= customTexAspect;\nuv += 0.5;vec4 sdColor = texture(uCustomTexture, uv);\nfloat msdf = median(sdColor.r, sdColor.g, sdColor.b);\nfloat m = 1. - sdColor.a;\nfloat sd = mix(msdf, sdColor.a, m);\nfloat screenPxDistance = screenPxRange(vec2(0.0833333)) * -(sd - 0.5);\nreturn screenPxDistance;\n}float getDistance(vec2 uv) {\nreturn sdCustom(uv);\n}float getDist(vec2 uv) {\nfloat sd = getDistance(uv);vec2 aspect = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 mousePos = (uMousePos * aspect);\nfloat mouseDistance = length(vTextureCoord * aspect - mousePos);\nfloat falloff = smoothstep(0.0, 0.8, mouseDistance);\nfloat asd = 2.0;asd = 0.5;asd = asd;float md = mix(0.02/falloff, 0.1/falloff, -asd * sd);\nmd = md * 1.5 * 0.0000;\nmd = max(md, 0.0);\nsd -= md;return sd;\n}float screenPxRange() {\nvec2 unitRange = vec2(0.5);\nvec2 screenTexSize = vec2(1.0)/fwidth(vTextureCoord);\nreturn max(0.5*dot(unitRange, screenTexSize), 1.0);\n}vec4 refrakt(float sd, vec2 st, vec4 bg) {vec2 offset = mix(vec2(0), normalize(st)/sd, length(st));offset *= 3.;vec4 r = vec4(0,0,0,1);\nfloat rdisp = mix(0.01, 0.008, 1.0000);\nfloat gdisp = mix(0.01, 0.01, 1.0000);\nfloat bdisp = mix(0.01, 0.012, 1.0000);\nvec2 uv = (vTextureCoord - 0.5) / mix(1., 4., 0.0000) + 0.5;\nr.r = texture(uTexture, uv + offset * (0.0300 - 0.5) * rdisp).r;\nr.g = texture(uTexture, uv + offset * (0.0300 - 0.5) * gdisp).g;\nr.b = texture(uTexture, uv + offset * (0.0300 - 0.5) * bdisp).b;\nfloat opacity = ceil(-sd);\nfloat smoothness = 0.005;\nopacity = smoothstep(0., smoothness, -sd);vec4 background = vec4(0);\nreturn mix(background, r + vec4(vec3(0, 0, 0)/(-sd * 50.), 1.) * 1.0000, opacity);\n}vec4 getEffect(vec2 st, vec4 bg) {\nfloat eps = 0.0005;float sd = getDist(st);\nfloat sd1 = getDist(st + vec2(eps, 0.0));\nfloat sd2 = getDist(st - vec2(eps, 0.0));\nfloat sd3 = getDist(st + vec2(0.0, eps));\nfloat sd4 = getDist(st - vec2(0.0, eps));vec4 r = refrakt(sd, st, bg);\nvec4 r1 = refrakt(sd1, st + vec2(eps, 0.0), bg);\nvec4 r2 = refrakt(sd2, st - vec2(eps, 0.0), bg);\nvec4 r3 = refrakt(sd3, st + vec2(0.0, eps), bg);\nvec4 r4 = refrakt(sd4, st - vec2(0.0, eps), bg);\nr = (r + r1 + r2 + r3 + r4) * 0.2;\nreturn r;\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nvec4 color = vec4(1);\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 st = uv - (vec2(0.49513570570460136, 0.4991079781452946) + mousePos);\nst *= aspect;\nst *= 1./(0.8600 + 0.2);\nst *= rot(0.0081 * 2.0 * PI);\ncolor = getEffect(st, bg);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"2d_sdf_shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sphere","usesPingPong":false,"trackMouse":0.03,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;const float STEPS = 16.0;\nconst float PI = 3.1415926;vec3 chromaticAbberation(vec2 st, float angle, float amount, float blend) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat rotation = angle * 360.0 * PI / 180.0;\nvec2 aberrated = amount * vec2(0.1 * sin(rotation) * aspectRatio, 0.1 * cos(rotation));\naberrated *= distance(st, vec2(0.5)) * 2.0;\nvec4 red = vec4(0);\nvec4 blue = vec4(0);\nvec4 green = vec4(0);\nfloat invSteps = 1.0 / STEPS;\nfloat invStepsHalf = invSteps * 0.5;\nfor(float i = 1.0; i <= STEPS; i++) {\nvec2 offset = aberrated * (i * invSteps);\nred += texture(uTexture, st - offset) * invSteps;\nblue += texture(uTexture, st + offset) * invSteps;\n}for (float i = 1.0; i <= STEPS; i++) {\nvec2 offset = aberrated * ((i * invSteps) - 0.5);\ngreen += texture(uTexture, st + offset) * invSteps;\n}\nreturn vec3(red.r, green.g, blue.b);\n}vec2 sphericalTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat tau) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nu -= uCenter;\nv -= vCenter;float s = sqrt(u * u + v * v);\nif (s > lensRadius)\nreturn vec2((u + uCenter) / aspectRatio, v + vCenter);float z = sqrt(lensRadius * lensRadius - s * s);float uAlpha = (1.0 - (1.0 / tau)) * asin(u / lensRadius);\nfloat vAlpha = (1.0 - (1.0 / tau)) * asin(v / lensRadius);u = uCenter + z * sin(uAlpha);\nv = vCenter + z * sin(vAlpha);return vec2(u/aspectRatio, v);\n}float circularIn(float t) {\nreturn 1.0 - sqrt(1.0 - t * t);\n}vec2 fisheyeTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat distortionScale\n) {\nfloat aspectRatio = uResolution.x / uResolution.y;vec2 dir = vec2(u - uCenter, v - vCenter);dir.x /= lensRadius;\ndir.y /= lensRadius;float dist = length(dir) * 0.15;if (dist < 1.0) {\nfloat theta = atan(dir.y, dir.x);float r = dist * 2.0 * PI;\nfloat z = sqrt(1.0 - r * r) + 0.25;\nfloat rDist = atan(r, z) / PI;\nfloat newDist = mix(dist, rDist, 5.);dir.x = newDist * cos(theta);\ndir.y = newDist * sin(theta);\n}dir.x *= lensRadius;\ndir.y *= lensRadius;return mix(vec2(u/aspectRatio, v), vec2(uCenter/aspectRatio, vCenter) + dir, 1.0000);\n}vec2 discTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat distortionScale) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nu -= uCenter;\nv -= vCenter;float s = sqrt(u * u + v * v);\nif (s > lensRadius)\nreturn vec2((u + uCenter) / aspectRatio, v + vCenter);\nfloat r = sqrt(u * u + v * v) / lensRadius;\nif(r == 0.0)\nreturn vec2(uCenter, vCenter);r = pow(r, distortionScale);\nfloat theta = atan(r);\nfloat rad = theta / r;u = rad * u + uCenter;\nv = rad * v + vCenter;return vec2(u/aspectRatio, v);\n}out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat mirrorX = aspectRatio;\nuv.x = uv.x * aspectRatio;\nvec2 sphereCoords = uv;\nvec2 pos = vec2(0.5, 0.5232514827092016) + mix(vec2(0), (uMousePos-0.5), 0.0300);\npos.x *= aspectRatio;float radius = 3.4200 * uResolution.x/max(uResolution.x, uResolution.y);if(0 == 0) {\nsphereCoords = sphericalTransformation(\nmix(sphereCoords.x, mirrorX - sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, mirrorX - pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 1.0000 * 9.\n);\n} else if(0 == 1) {\nsphereCoords = discTransformation(\nmix(sphereCoords.x, mirrorX - sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, mirrorX - pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 1.0000 * 9.\n);\n} else if(0 == 2) {\nsphereCoords = fisheyeTransformation(\nmix(sphereCoords.x, mirrorX - sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, mirrorX - pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 1.0000 * 9.\n);\n}vec2 scaledCoords = (sphereCoords - 0.5) + 0.5;\nvec4 sphere = texture(uTexture, clamp(scaledCoords, 0.0, 1.0));\nfloat distFromPos = distance(uv, pos);\nfloat edgeSmooth = 0.001;\nfloat insideSphere = 1.0 - smoothstep(radius/2.0 - edgeSmooth, radius/2.0, distFromPos);\nfloat insideSphereAlpha = 1.0 - smoothstep(radius/2.0 + 0.002 - edgeSmooth, radius/2.0 + 0.002, distFromPos);\nsphere.rgb = chromaticAbberation(scaledCoords, atan(scaledCoords.y, scaledCoords.x), distFromPos * 0.0700, 1.0);\ncolor = mix(color, sphere, insideSphere);\ncolor.rgb += vec3((1.0000-0.5)*2.) * mix(0., circularIn(smoothstep(0., radius, distFromPos)), insideSphere);\nif(1 == 1) {\ncolor.a = insideSphereAlpha;\ncolor.rgb = mix(vec3(0), color.rgb, insideSphereAlpha);\n}\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"lens_distort"},{"breakpoints":[{"min":992,"name":"Desktop","max":null,"props":{"exposure":0.44}},{"max":575,"min":0,"props":{"exposure":0.49},"name":"Mobile"}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"bloom","usesPingPong":false,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uExposure;out vec4 fragColor;float luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}vec4 thresholdPass(vec4 color) {\ncolor.rgb = pow(color.rgb, vec3(1.0/2.2));\ncolor.rgb = 1.2 * (color.rgb - 0.5) + 0.5;\nvec4 bloom = color * smoothstep(uExposure - 0.1, uExposure, luma(color));\nreturn vec4(bloom.rgb, color.a);\n}vec4 getColor(vec4 color) {\nreturn thresholdPass(color);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfragColor = getColor(color);\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 dir;\nif (diamond) {\ndir = vertical ? vec2(1, 1) : vec2(1, -1);\n} else {\ndir = vertical ? vec2(0, 1) : vec2(1, 0);\n}\ndir *= vec2(0.5000, 1. - 0.5000);\ndir.x /= aspectRatio;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;radius *= 0.7100;\nfor (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = mix(0.015, 0.025, radius) * float(i)/8.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) {\nreturn blur(uv, vertical, radius, diamond);\n}vec4 getColor(vec4 color) {\nreturn blurPass(vTextureCoord, false, 30., 1.25, true);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfragColor = getColor(color);\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform float uExposure;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}float getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 dir;\nif (diamond) {\ndir = vertical ? vec2(1, 1) : vec2(1, -1);\n} else {\ndir = vertical ? vec2(0, 1) : vec2(1, 0);\n}\ndir *= vec2(0.5000, 1. - 0.5000);\ndir.x /= aspectRatio;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;radius *= 0.7100;\nfor (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = mix(0.015, 0.025, radius) * float(i)/8.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}vec4 thresholdPass(vec4 color) {\ncolor.rgb = pow(color.rgb, vec3(1.0/2.2));\ncolor.rgb = 1.2 * (color.rgb - 0.5) + 0.5;\nvec4 bloom = color * smoothstep(uExposure - 0.1, uExposure, luma(color));\nreturn vec4(bloom.rgb, color.a);\n}vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) {\nvec4 blurred = blur(uv, vertical, radius, diamond);\nreturn (thresholdPass(texture(uBgTexture, uv)) * 0.25 + blurred * intensity);\n}vec4 getColor(vec4 color) {\nreturn blurCombinePass(vTextureCoord, true, 30., 1.25, true);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfragColor = getColor(color);\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 dir;\nif (diamond) {\ndir = vertical ? vec2(1, 1) : vec2(1, -1);\n} else {\ndir = vertical ? vec2(0, 1) : vec2(1, 0);\n}\ndir *= vec2(0.5000, 1. - 0.5000);\ndir.x /= aspectRatio;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;radius *= 0.7100;\nfor (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = mix(0.015, 0.025, radius) * float(i)/8.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) {\nreturn blur(uv, vertical, radius, diamond);\n}vec4 getColor(vec4 color) {\nreturn blurPass(vTextureCoord, false, 10., 1., false);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfragColor = getColor(color);\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 dir;\nif (diamond) {\ndir = vertical ? vec2(1, 1) : vec2(1, -1);\n} else {\ndir = vertical ? vec2(0, 1) : vec2(1, 0);\n}\ndir *= vec2(0.5000, 1. - 0.5000);\ndir.x /= aspectRatio;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;radius *= 0.7100;\nfor (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = mix(0.015, 0.025, radius) * float(i)/8.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) {\nreturn blur(uv, vertical, radius, diamond);\n}vec4 getColor(vec4 color) {\nreturn blurPass(vTextureCoord, true, 10., 1., false);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfragColor = getColor(color);\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;float luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}vec4 finalPass(vec4 bloomColor) {\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\nbloomColor.rgb *= vec3(0, 0.5647058823529412, 0.7411764705882353);\nbloomColor.rgb += dither;\nbloomColor.a = luma(bloomColor);\nvec4 sceneColor = texture(uBgTexture, vTextureCoord);\nvec4 finalColor = mix(sceneColor, sceneColor + bloomColor, 1.0000 * 1.9);\nreturn finalColor;\n}vec4 getColor(vec4 color) {\nreturn finalPass(color);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfragColor = getColor(color);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{"exposure":{"name":"uExposure","type":"1f","value":0.5}},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25,"includeBg":true},{"prop":"pass","value":5,"downSample":0.5},{"prop":"pass","value":6,"downSample":0.5,"includeBg":true},{"prop":"pass","value":7,"downSample":1,"includeBg":true}]},"id":"bloom"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;const float PI2 = 6.28318530718;vec4 getBrightAreas(vec2 uv) {\nvec4 color = texture(uTexture, uv);\nfloat lum = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor = color * smoothstep(0.5000 - 0.1, 0.5000, lum);\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getBrightAreas(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(0 == 1) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI2 = 6.28318530718;float interleavedGradientNoise(vec2 st) {\nreturn fract(52.9829189 * fract(dot(st, vec2(0.06711056, 0.00583715))));\n}vec4 godRays(vec2 st) {\nvec3 color = vec3(0);\nfloat decay = mix(0.89, 0.965, 0.4380);\nvec2 pos = vec2(0.49742589686430955, 0.49039001496008916) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0000);\nfloat weight = 1.0;\nfloat MAX_ITERATIONS = 32.0;\nvec2 stepDir = (pos - st) / MAX_ITERATIONS * (0.25 + min(1., 0.4380)) * 0.75;\nfloat noise = interleavedGradientNoise(st * uResolution);\nvec2 sampleUv = st + stepDir * noise;\nvec2 perpDir = vec2(-stepDir.y, stepDir.x);\nfloat intensity = 2.8 * 0.2200;for (float i = 0.0; i < MAX_ITERATIONS; i++) {\nfloat theta = i/MAX_ITERATIONS;\nsampleUv += stepDir + (perpDir * theta * sin((noise * 0.25) * (1.0 + theta) * 50.0)) * 1.0000 * 0.25;\ncolor += texture(uTexture, sampleUv).rgb * weight * intensity;\nweight *= decay;\nif(weight < 0.05) break;\n}\nreturn vec4(color / MAX_ITERATIONS, 1.0);\n}vec4 getGodRays(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nif(0.2200 <= 0.01) {\nreturn bg;\n}\nvec4 rays = godRays(uv);\nrays.rgb *= vec3(1, 1, 1);vec4 color;\ncolor.rgb = bg.rgb + rays.rgb;\ncolor.a = bg.a + rays.r;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getGodRays(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(1 == 1) {\nfragColor = color;} else {\nfragColor = color;\n}\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"includeBg":true}]},"id":"god_rays"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.5000, 1.0 - 0.5000);\nfloat halfRadius = 0.7720 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0.5);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;finalColor = mix(bg.rgb, mix(bg.rgb, vec3(0, 0, 0), 1.0000), falloff);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"vignette"}],"options":{"name":"Copy of Untitled project","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.4","id":"RSV3KDoSGB26jqqPorCv"}